"use strict";(self.webpackChunkkube_project_github_io=self.webpackChunkkube_project_github_io||[]).push([[81],{8350:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var t=i(4848),s=i(8453);const o={sidebar_position:1},r="High-level Components",a={id:"project-basics/high-level-components",title:"High-level Components",description:"Let's take a look at what components this project consists of.",source:"@site/docs/project-basics/high-level-components.mdx",sourceDirName:"project-basics",slug:"/project-basics/high-level-components",permalink:"/docs/project-basics/high-level-components",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Project - Basics",permalink:"/docs/category/project---basics"},next:{title:"Extending the Project",permalink:"/docs/category/extending-the-project"}},c={},h=[{value:"Database",id:"database",level:2},{value:"NSQ",id:"nsq",level:2},{value:"Receiver",id:"receiver",level:2},{value:"Image Processor",id:"image-processor",level:2},{value:"Consume",id:"consume",level:3},{value:"ProcessImages",id:"processimages",level:3},{value:"Circuit Breaker",id:"circuit-breaker",level:3},{value:"Face Recognition Service",id:"face-recognition-service",level:2},{value:"Face Recognition",id:"face-recognition",level:2},{value:"Frontend",id:"frontend",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"high-level-components",children:"High-level Components"}),"\n",(0,t.jsx)(n.p,{children:"Let's take a look at what components this project consists of."}),"\n",(0,t.jsx)(n.h2,{id:"database",children:"Database"}),"\n",(0,t.jsx)(n.p,{children:"In all distributed applications there has to be a sync point between the processed data. In this application that point\nis the database. All of the components use transactions to stay up-to-date with all changes and to prevent data races."}),"\n",(0,t.jsx)(n.p,{children:"The database could be sharded and distributed, but we won't cover that in this guide."}),"\n",(0,t.jsx)(n.h2,{id:"nsq",children:"NSQ"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/nsqio/go-nsq",children:"NSQ"})," was choosen as a message broker between two of the components to decouple the\nworkload handling. Basically, one of the components deals with processing incoming images and then handles over image\nids through the queue to the next component whihc will deal with the image recognition."]}),"\n",(0,t.jsx)(n.p,{children:"The queue is pretty sturdy, handles multiple processors and produces, can be distributed and handles re-sending unprocessed\nentries."}),"\n",(0,t.jsx)(n.h2,{id:"receiver",children:"Receiver"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"https://github.com/kube-project/receiver-service",children:"receiver service"})," is the entry point into the whole process. It's an API which receives a request in the following format:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'curl -d \'{"path":"/unknown_images/unknown0001.jpg"}\' http://127.0.0.1:8000/image/post\n'})}),"\n",(0,t.jsx)(n.p,{children:"Once that request is received the following process is kicked off:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["write the path in to the database and create an entry in ",(0,t.jsx)(n.code,{children:"Pending"})," state"]}),"\n",(0,t.jsx)(n.li,{children:"if the write is successful send the image ID to NSQ"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It can process multiple images at once as well."}),"\n",(0,t.jsx)(n.h2,{id:"image-processor",children:"Image Processor"}),"\n",(0,t.jsx)(n.p,{children:"Here is where the excitement begins. When Image Processor first runs it creates two Go routines. These are..."}),"\n",(0,t.jsx)(n.h3,{id:"consume",children:"Consume"}),"\n",(0,t.jsx)(n.p,{children:"This is an NSQ consumer. It has three integral jobs. Firstly, it listens for messages on the queue. Secondly, when there\nis a message, it appends the received ID to a thread safe slice of IDs that the second routine processes. And lastly,\nit signals the second routine that there is work to be do with a mediator."}),"\n",(0,t.jsx)(n.h3,{id:"processimages",children:"ProcessImages"}),"\n",(0,t.jsx)(n.p,{children:"This routine processes an ID that it gets from the consumer. The processing of a single ID can be seen in the following\nlinear steps:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Establish a gRPC connection to the Face Recognition service (explained under Face Recognition)"}),"\n",(0,t.jsx)(n.li,{children:"Retrieve the image record from the database"}),"\n",(0,t.jsxs)(n.li,{children:["Setup two functions for the ",(0,t.jsx)(n.a,{href:"#circuit-breaker",children:"Circuit Breaker"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Function 1: The main function which runs  the RPC method call"}),"\n",(0,t.jsx)(n.li,{children:"Function 2: A health check for the Ping of the circuit breaker"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Call Function 1 which sends the path of the image to the face recognition service. This path should be accessible by\nthe face recognition service. Preferably something shared like an NFS"}),"\n",(0,t.jsx)(n.li,{children:"If this call fails, update the image record as FAILED PROCESSING"}),"\n",(0,t.jsx)(n.li,{children:"If it succeeds, an image name should come back which corresponds to a person in the db. It runs a joined SQL query\nwhich gets the corresponding person's ID"}),"\n",(0,t.jsx)(n.li,{children:"Update the Image record in the database with PROCESSED status and the ID of the person that image was identified as"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This service can be replicated. In other words, more than one can run at the same time."}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"This whole process could be made even more resilient by batch processing several IDs received from the consumer service.\nRight now it has a 1 length buffered channel only."})}),"\n",(0,t.jsx)(n.h3,{id:"circuit-breaker",children:"Circuit Breaker"}),"\n",(0,t.jsx)(n.p,{children:"A system in which replicating resources requires little to no effort, there still can be cases where, for example, the\nnetwork goes down, or there are communication problems of any kind between two services. I like to implement a little\ncircuit breaker around the gRPC calls for fun."}),"\n",(0,t.jsxs)(n.p,{children:["The code is located ",(0,t.jsx)(n.a,{href:"https://github.com/kube-project/image-processor-service/blob/c23655eaec2efce139be7f29603c8a767999a29f/pkg/providers/circuitbreaker/circuitbreaker.go",children:"here"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"This is how it works:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"kube circuit",src:i(9223).A+"",width:"800",height:"576"})}),"\n",(0,t.jsx)(n.p,{children:"Once there are 5 unsuccessful calls to the service, the circuit breaker activates, not allowing any more calls to go\nthrough. After a configured amount of time, it will send a Ping call to the service to see if it's back up. If that\nstill errors out, it will increase the timeout. If not, it opens the circuit, allowing traffic to proceed."}),"\n",(0,t.jsx)(n.h2,{id:"face-recognition-service",children:"Face Recognition Service"}),"\n",(0,t.jsx)(n.h2,{id:"face-recognition",children:"Face Recognition"}),"\n",(0,t.jsxs)(n.p,{children:["Here is where the identification happens. I decided to make this a gRPC based service for the  sole purpose of its\nflexibility. I started writing it in Go but decided that a Python implementation would be much sorter. In fact,\nexcluding the gRPC code, the recognition part is approximately 7 lines of Python code. I'm using this fantastic library\nwhich contains all the C bindings to dlib. ",(0,t.jsx)(n.a,{href:"https://github.com/ageitgey/face_recognition",children:"Face Recognition"}),". Having an\nAPI contract here means that I can change the implementation anytime as long as it adheres to the contract."]}),"\n",(0,t.jsxs)(n.p,{children:["Please note that there exist a great Go library OpenCV. I was about to use it but they had yet to write the C bindings\nfor that part of OpenCV. It's called ",(0,t.jsx)(n.a,{href:"https://gocv.io/",children:"GoCV"}),". Check them out! They have some pretty amazing things,\nlike real-time camera feed processing that only needs a couple of lines of code."]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["There is also now ",(0,t.jsx)(n.a,{href:"https://github.com/Kagami/go-face",children:"Kagami/go-face"})," which comes pretty close, but has been discontinued."]}),(0,t.jsxs)(n.p,{children:["There is also ",(0,t.jsx)(n.a,{href:"https://github.com/esimov/pigo",children:"pigo"})," but that is for face ",(0,t.jsx)(n.em,{children:"detection"}),"."]})]}),"\n",(0,t.jsxs)(n.p,{children:["The python library is simple in nature. Have a set of images of people you know. I have a folder with a couple of images\nnamed, ",(0,t.jsx)(n.code,{children:"hannibal_1.jpg, hannibal_2.jpg, gergely_1.jpg, john_doe.jpg"}),". In the database I have two tables named,\n",(0,t.jsx)(n.code,{children:"person, person_images"}),". They look like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"+----+----------+\n| id | name     |\n+----+----------+\n|  1 | Gergely  |\n|  2 | John Doe |\n|  3 | Hannibal |\n+----+----------+\n+----+----------------+-----------+\n| id | image_name     | person_id |\n+----+----------------+-----------+\n|  1 | hannibal_1.jpg |         3 |\n|  2 | hannibal_2.jpg |         3 |\n+----+----------------+-----------+\n"})}),"\n",(0,t.jsx)(n.p,{children:"The face recognition library returns the name of the image from the known people which matches the person on the\nunknown image. After that, a simple joined query -like this- will return the person in question."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"select person.name, person.id from person inner join person_images as pi on person.id = pi.person_id where image_name = 'hannibal_2.jpg';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The gRPC call returns the ID of the person which is then used to update the image's ",(0,t.jsx)(n.code,{children:"person"})," column."]}),"\n",(0,t.jsx)(n.h2,{id:"frontend",children:"Frontend"}),"\n",(0,t.jsx)(n.p,{children:"This is only a simple table view with Go's own html/template used to render a list of images."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},9223:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/kube_circuit1-9d943d2e9e9724889cbfc829159e2ba5.png"},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);